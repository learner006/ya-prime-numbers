=== РАССУЖДЕНИЯ
1.
Сначала придумаем в меру неоптимальное ПРАВИЛЬНОЕ решение, потом будем его 
улучшать.

2.
Очевидно, что нужна функция, которая тестирует натуральное число на простоту.
Единственный входной параметр: натуральное число.
Возвращаемое значение: булев тип

Предположим, что она работает для всех натуральных чисел 1, 2, 3... и 
перейдем к главному алгоритму задачи.

(Corner case: 1 НЕ является простым числом.)


3.
=== АЛГОРИТМ
1) Входное натуральное число обозначим за [inputNumber];

2) Количество найденных простых чисел будем хранить в переменной 
[primeNumberCount]. Присвоим ей начальное значение 0.

3) Если введённое число больше, чем 2, то [primeNumberCount] = 1 (corner case);

4) Обозначим переменую цикла буквой [n] и будем перебирать натуральные 
числа, начиная с 3, с шагом 2. При этом [n] < [inputNumber].
(Таким образом мы исключаем чётные числа из проверки на простоту). 

5) Если [n] является простым числом, увеличиваем переменную 
[primeNumberCount] на 1

6) По завершению цикла выводим [primeNumberCount] /КОНЕЦ/

4.
=== АЛГОРИТМ ПРОВЕРКИ _НАТУРАЛЬНОГО_ ЧИСЛА НА ПРОСТОТУ
1) Обозначим число за [p_n]
2) Если [p_n] равно 1 или [p_n] четное, возвращаем ЛОЖЬ /КОНЕЦ/
3) Если [p_n] равно 2,3 или 5, возвращаем ИСТИНА /КОНЕЦ/
4) Обозначим переменную цикла за [divisor] и будем присваивать ей значения 
от 3-х до sqrt([p_n]) с шагом 2
5) Если остаток от деления [p_n] на [divisor] равен 0, значит, введённом 
число не является простым. Возвращаем ЛОЖЬ /КОНЕЦ/
6) Если цикл закончился, значит, введённое число является простым, 
возвращаем ИСТИНА /КОНЕЦ/
